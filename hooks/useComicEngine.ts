
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/

import { useReducer, useCallback, useRef } from 'react';
import { 
  ComicState, 
  ComicAction, 
  ComicFace, 
  StoryConfig, 
  Persona,
  GENRES,
  TONES,
  LANGUAGES,
  INITIAL_PAGES,
  TOTAL_PAGES,
  BACK_COVER_PAGE,
  BATCH_SIZE,
  DECISION_PAGES
} from '../types';
import { AiService } from '../services/aiService';

const initialState: ComicState = {
  status: 'setup',
  comicFaces: [],
  currentSheetIndex: 0,
  hero: null,
  friend: null,
  config: {
    genre: GENRES[0],
    tone: TONES[0],
    language: LANGUAGES[0].code,
    customPremise: "",
    richMode: true,
  },
  error: null,
};

function reducer(state: ComicState, action: ComicAction): ComicState {
  switch (action.type) {
    case 'SET_HERO':
      return { ...state, hero: action.payload };
    case 'UPDATE_HERO':
      return { ...state, hero: state.hero ? { ...state.hero, ...action.payload } : null };
    case 'SET_FRIEND':
      return { ...state, friend: action.payload };
    case 'UPDATE_FRIEND':
      return { ...state, friend: state.friend ? { ...state.friend, ...action.payload } : null };
    case 'UPDATE_CONFIG':
      return { ...state, config: { ...state.config, ...action.payload } };
    case 'START_ADVENTURE':
      return { ...state, status: 'generating', error: null };
    case 'TRANSITION_COMPLETE':
      return { ...state, status: 'reading' };
    case 'ADD_FACES': {
      const existingIds = new Set(state.comicFaces.map(f => f.id));
      const uniqueNew = action.payload.filter(f => !existingIds.has(f.id));
      return { 
        ...state, 
        comicFaces: [...state.comicFaces, ...uniqueNew].sort((a, b) => (a.pageIndex || 0) - (b.pageIndex || 0)) 
      };
    }
    case 'UPDATE_FACE':
      return {
        ...state,
        comicFaces: state.comicFaces.map(f => 
          f.id === action.payload.id ? { ...f, ...action.payload.updates } : f
        )
      };
    case 'SET_SHEET_INDEX':
      return { ...state, currentSheetIndex: action.payload };
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    case 'RESET':
      return initialState;
    default:
      return state;
  }
}

export const useComicEngine = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  // Ref used only to prevent duplicate batch triggers, not for state reading
  const generatingPagesRef = useRef<Set<number>>(new Set());

  // Actions
  const setHero = useCallback((p: Persona | null) => dispatch({ type: 'SET_HERO', payload: p }), []);
  const updateHero = useCallback((updates: Partial<Persona>) => dispatch({ type: 'UPDATE_HERO', payload: updates }), []);
  
  const setFriend = useCallback((p: Persona | null) => dispatch({ type: 'SET_FRIEND', payload: p }), []);
  const updateFriend = useCallback((updates: Partial<Persona>) => dispatch({ type: 'UPDATE_FRIEND', payload: updates }), []);
  
  const updateConfig = useCallback((updates: Partial<StoryConfig>) => dispatch({ type: 'UPDATE_CONFIG', payload: updates }), []);
  
  const generateBatch = useCallback(async (startPage: number, count: number, currentFaces: ComicFace[], currentHero: Persona, currentFriend: Persona | null, currentConfig: StoryConfig) => {
    const pagesToGen: number[] = [];
    for (let i = 0; i < count; i++) {
        const p = startPage + i;
        if (p <= TOTAL_PAGES && !generatingPagesRef.current.has(p)) {
            pagesToGen.push(p);
        }
    }
    
    if (pagesToGen.length === 0) return;
    pagesToGen.forEach(p => generatingPagesRef.current.add(p));

    // Optimistically add placeholders
    const newFaces: ComicFace[] = pagesToGen.map(pageNum => ({
      id: `page-${pageNum}`,
      type: pageNum === BACK_COVER_PAGE ? 'back_cover' : 'story',
      choices: [],
      isLoading: true,
      pageIndex: pageNum,
    }));
    
    dispatch({ type: 'ADD_FACES', payload: newFaces });

    // Create a local history array that accumulates changes as we go through the batch
    // This solves the concurrency issue: subsequent pages in this batch will see the beats generated by previous ones
    let batchHistory = [...currentFaces, ...newFaces];

    try {
      // Process sequentially to maintain narrative continuity within the batch
      for (const pageNum of pagesToGen) {
        const faceId = `page-${pageNum}`;
        const type = pageNum === BACK_COVER_PAGE ? 'back_cover' : 'story';
        const isDecision = DECISION_PAGES.includes(pageNum);

        let beat;
        if (type === 'back_cover') {
           beat = { scene: "Thematic teaser image", choices: [], focus_char: 'other' as const };
        } else {
           // We use the batchHistory which gets updated in this loop
           beat = await AiService.generateBeat(batchHistory, pageNum, isDecision, currentConfig, currentHero, currentFriend);
        }
        
        // Check for new sidekick generation
        let activeFriend = currentFriend;
        if (beat.focus_char === 'friend' && !activeFriend && type === 'story') {
           try {
              const desc = currentConfig.genre === 'Custom' ? "A fitting sidekick for this story" : `Sidekick for ${currentConfig.genre} story.`;
              activeFriend = await AiService.generatePersona(desc, currentConfig.genre);
              setFriend(activeFriend);
           } catch (e) {
              beat.focus_char = 'other';
           }
        }

        // Update local history with the narrative beat so the next page in loop sees it
        batchHistory = batchHistory.map(f => f.id === faceId ? { ...f, narrative: beat, choices: beat.choices, isDecisionPage: isDecision } : f);
        
        // Dispatch text update to UI immediately
        dispatch({ type: 'UPDATE_FACE', payload: { id: faceId, updates: { narrative: beat, choices: beat.choices, isDecisionPage: isDecision } } });

        // Generate Image
        const url = await AiService.generateImage(beat, type, currentConfig, currentHero, activeFriend);
        
        // Update local history with image (though text is more important for next prompt)
        batchHistory = batchHistory.map(f => f.id === faceId ? { ...f, imageUrl: url, isLoading: false } : f);

        dispatch({ type: 'UPDATE_FACE', payload: { id: faceId, updates: { imageUrl: url, isLoading: false } } });
        
        generatingPagesRef.current.delete(pageNum);
      }
    } catch (e) {
      console.error("Batch Generation Error:", e);
      const msg = String(e);
      if (msg.includes('Requested entity was not found') || msg.includes('API_KEY_INVALID')) {
         dispatch({ type: 'SET_ERROR', payload: "API_KEY_ERROR" });
      }
    } finally {
      pagesToGen.forEach(p => generatingPagesRef.current.delete(p));
    }
  }, [setFriend]);

  const launchStory = useCallback(async () => {
    if (!state.hero) return;
    dispatch({ type: 'START_ADVENTURE' });
    
    // Pick tone if needed
    let finalTone = state.config.tone;
    if (!state.config.tone) {
       // logic for random tone selection if not set could go here
       // but we initialize with one
    }

    // Generate Cover
    const coverFace: ComicFace = { id: 'cover', type: 'cover', choices: [], isLoading: true, pageIndex: 0 };
    dispatch({ type: 'ADD_FACES', payload: [coverFace] });
    generatingPagesRef.current.add(0);

    try {
        await AiService.generateImage({ scene: "Cover", choices: [], focus_char: 'hero' }, 'cover', state.config, state.hero, state.friend)
          .then(url => {
              dispatch({ type: 'UPDATE_FACE', payload: { id: 'cover', updates: { imageUrl: url, isLoading: false } } });
              generatingPagesRef.current.delete(0);
          });
    } catch (e) {
        console.error(e);
        dispatch({ type: 'SET_ERROR', payload: "API_KEY_ERROR" });
        return;
    }

    setTimeout(() => {
        dispatch({ type: 'TRANSITION_COMPLETE' });
        // Start first batch. IMPORTANT: Pass current state snapshots
        generateBatch(1, INITIAL_PAGES, [coverFace], state.hero!, state.friend, state.config);
        
        setTimeout(() => {
           generateBatch(3, 3, [coverFace], state.hero!, state.friend, state.config);
        }, 500); 
        
    }, 1100);

  }, [state.config, state.hero, state.friend, generateBatch]);

  const handleChoice = useCallback(async (pageIndex: number, choice: string) => {
    dispatch({ type: 'UPDATE_FACE', payload: { id: `page-${pageIndex}`, updates: { resolvedChoice: choice } } });
    
    // Calculate next batch
    const maxPage = Math.max(...state.comicFaces.map(f => f.pageIndex || 0));
    
    if (maxPage + 1 <= TOTAL_PAGES) {
      const updatedFaces = state.comicFaces.map(f => f.pageIndex === pageIndex ? { ...f, resolvedChoice: choice } : f);
      generateBatch(maxPage + 1, BATCH_SIZE, updatedFaces, state.hero!, state.friend, state.config);
    }
  }, [state.comicFaces, state.hero, state.friend, state.config, generateBatch]);

  const setSheetIndex = useCallback((idx: number) => dispatch({ type: 'SET_SHEET_INDEX', payload: idx }), []);
  const reset = useCallback(() => { 
      generatingPagesRef.current.clear();
      dispatch({ type: 'RESET' }); 
  }, []);

  return {
    state,
    actions: {
      setHero,
      updateHero,
      setFriend,
      updateFriend,
      updateConfig,
      launchStory,
      handleChoice,
      setSheetIndex,
      reset,
      clearError: () => dispatch({ type: 'SET_ERROR', payload: '' })
    }
  };
};
